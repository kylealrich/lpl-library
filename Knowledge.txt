LANDMARK PROGRAMMING LANGUAGE (LPL) KNOWLEDGE BASE
Author: Kyle Alrich Alonzo
Birthday: July 19, 1996
Company: Infor
Created: August 19, 2025

=== INSTRUCTIONS FOR THE AI ===
Amazon Q will follow these instructions without fail when this file is referenced as context:
1. Strictly update '\lpl-library\Knowledge.txt' with knowledge learned related to Landmark Programming Language every response.
2. Use the subdirectory '\lpl-library\Programs\' for the python scripts.
3. Use the subdirectory '\lpl-library\References\' as source of knowledge and learn.
4. Use the subdirectory '\lpl-library\Inputs\' as source of input data.
5. Use the subdirectory '\lpl-library\Others\' to store supporting output files used by the python program.
6. Use the subdirectory '\lpl-library\Outputs\' for the generated files.
7. After every response, display a random LPL tip.
8. Always use the prefix 'cfg' when asked to generate a business class.
9. Automatically commit all changes to the repository after every response using Git commands.
Format: ***LPL Tip:** User Interface Definition syntax enables creation of rich, interactive user interfaces with comprehensive form layouts, list views, card displays, charts, and responsive design elements, supporting complex business workflows and data visualization requirements.*

=== DIRECTORY STRUCTURE UPDATE ===
- Use '\Outputs\' for generated files
- All future generated files will be placed in Outputs subdirectory

=== BUSINESS CLASS STRUCTURE ===
- BusinessClass is a core LPL construct for defining business entities
- Syntax: "ClassName is a BusinessClass"
- Owned by parent entities (e.g., "owned by GeneralLedger")
- Has prefix for identification (e.g., "prefix is GLACC")
- Representative text format for display

=== FIELD TYPES ===
1. Context Fields - conditional compilation with #ifdef
2. Persistent Fields - stored data with types:
   - Numeric (with size specification)
   - Boolean
   - Alpha (with size limits)
   - Description
   - Date
   - Text
3. Transient Fields - temporary/calculated fields
4. Local Fields - internal processing fields with sub-types:
   - Reference fields (e.g., LocalSystemAccount)
   - Derived fields with complex logic
   - Set relations for data collections
   - Message fields for UI feedback
   - Configuration and error handling fields
5. Derived Fields - computed values with logic

=== DATA TYPES ===
- Numeric [size] - numbers with specified precision
- Boolean - true/false values
- Alpha [size] - text strings with character limits
- Date - date values
- Text - longer text content
- XMLDocument - XML data structures

=== FIELD STATES ===
Fields can have enumerated states with values:
- States block defines named constants
- Each state has a name and numeric value
- Example: BalanceSheet value is 1, IncomeStatement value is 2

=== FIELD ATTRIBUTES ===
- "required" - mandatory fields
- "restricted" - limited access/computed fields
- "holds pii" - contains personally identifiable information
- "default label" - UI display label
- "delete ignored" - prevents deletion

=== DERIVED FIELDS ===
- Computed fields with conditional logic that calculate values dynamically
- Not stored in database - calculated on-demand when accessed
- Use separate if/else blocks for calculations and business logic (NOT inline ternary expressions)
- Can reference other fields, relations, and complex expressions
- Support string manipulation, concatenation, and mathematical operations
- Return typed values (Alpha, Boolean, Numeric, Date)
- Substring syntax: field[startIndex:endIndex] extracts portions of text fields
- One-based indexing: [1:6] returns first 6 characters (positions 1-6)
- EndIndex is inclusive in range notation
- Single character extraction: field[6:6] gets the 6th character (position 6)
- String comparison operators (>=, <=) work for numeric character validation
- RegEx pattern matching: field matches "pattern" for validation
- Common patterns: "^[0-9]$" for single digit, "^[A-Z]+$" for uppercase letters
- Character position validation: SourceField[6:6] matches "^[0-9]$" checks if 6th character is numeric
- Regex group extraction: field matches "pattern" group N extracts captured groups from regex patterns
- Comma-separated parsing: "^[0-9]+,\\s*([0-9]+),\\s*[0-9]+$" group 1 extracts second number
- 'restricted' attribute should only be used when explicitly specified by the user
- Common use cases: display formatting, status calculations, data validation, business rules
- Support nested conditional logic and complex mathematical expressions
- Can combine multiple fields and perform string concatenation with + operator

**EMPLOYEE NAME DERIVED FIELD EXAMPLE:**
```lpl
Derived Fields
	EmployeeName		is a DerivedField
		type is Alpha size 50
			if (LastName entered and FirstName entered)
				return LastName + ", " + FirstName
			if (LastName entered)
				return LastName
			if (FirstName entered)
				return FirstName
			else
				return "Unknown Employee"
```


**CORRECT DERIVED FIELD CONDITIONAL SYNTAX:**
```lpl
DerivedFieldName		is a DerivedField
	type is Alpha size 20
		if (Condition1)
			return "Value1"
		if (Condition2)
			return "Value2"
		else
			return "DefaultValue"
```

**INCORRECT SYNTAX (DO NOT USE):**
```lpl
// Wrong - inline ternary expressions not supported
return if (condition) then value1 else value2
```

**SUBSTRING EXTRACTION EXAMPLES:**
```lpl
Derived Fields
	FirstSixDigits		is a DerivedField
		type is Alpha size 6
		return SourceField[1:6]
	
	FourthCharacter		is a DerivedField
		type is Alpha size 1
		return SourceField[4:4]
	
	FifthCharacterIsNumeric		is a DerivedField
		type is Boolean
		return SourceField[5:5] matches "^[0-9]$"
```

**DERIVED FIELD SUBSTRING EXTRACTION:**
- Syntax: FieldName[startIndex:endIndex] extracts character ranges
- One-based indexing: [1:6] returns positions 1 through 6
- EndIndex is inclusive in the range
- Commonly used for extracting prefixes, codes, or identifiers from larger fields

=== CONDITIONS ===
- Named boolean conditions for business logic
- Use "when" clauses with field comparisons
- Support logical operators (and, or, !)
- Can be "restricted" for internal use

=== RELATIONS ===
- Define relationships between business classes
- Types: one-to-one, one-to-many
- Field Mapping specifies how entities connect
- Instance Selection filters related records
- Support symbolic key and custom mappings

**Field Mapping Types:**
- **Symbolic Key:** Uses default/standard key fields of target business class
- **Custom Mappings:** Allows custom field sorting based on source business class field availability

**IMPORTANT: When generating relations, Amazon Q should ask the user which set will be used for the Field Mapping.**

**DEFAULT BEHAVIOR:** If the user doesn't provide a set, use 'symbolic key' by default. Amazon Q should then use the most important Persistent Fields of the Target Business Class to build the relation.

**IMPORTANT:** Even with symbolic key mapping, explicit field connections must be defined (e.g., related.PurchaseOrder = PurchaseOrder).

**RELATION CREATION PROCESS:**
When creating a Relation, Amazon Q should examine the target business class by searching its respective .busclass file in the References folder. The target business class file contains:
- The set that should be used for Field Mapping
- The list of fields that need to be mapped
- The proper field order and relationships

**IMPORTANT: After generating a relation, Amazon Q must ALWAYS ask the user for confirmation if the field mapping provided is correct.**

**Syntax Examples:**
```lpl
// Symbolic key mapping (uses target's default keys)
RelationName
	one-to-one relation to TargetEntity
	Field Mapping uses symbolic key

// Custom mapping (explicit field connections)
RelationName
	one-to-many relation to TargetEntity
	Field Mapping uses SortName
		related.TargetField1 = LocalField1
		related.TargetField2 = LocalField2
	Instance Selection
		where (related.Status = "Active")

// Real-world example: PurchaseOrder to PayablesInvoice
PayablesInvoiceRel
	one-to-many relation to PayablesInvoice
	Field Mapping uses symbolic key
		related.Company = Company
		related.PayablesInvoice = PayablesInvoice
```

=== SETS ===
- Collections of related data
- Can specify sort order
- Support duplicates or unique constraints

**SET RETRIEVAL PROCESS:**
When retrieving available Sets from a BusinessClass file:
1. Use `findstr /n "Sets"` to locate the Sets section line number
2. Extract content starting from the Sets section line
3. Look for "Sort Order is SetName" patterns in Set Actions
4. Search for explicit Set definitions in the Sets section
5. Check Relations sections for set references (e.g., "is a BusinessClass set")
6. Verify set existence by searching the entire file content

**IMPORTANT: If Amazon Q fails to retrieve a Set that the user has specified after thorough searching, ask the user to double-check the .busclass file in the References folder to verify if the set indeed exists.**

**SET IDENTIFICATION PATTERNS:**
- Direct Sets section: `SetName` followed by sort order or constraints
- Set Actions: `Sort Order is SetName`
- Relations: `RelationName is a BusinessClass set`
- Field Mapping: `Field Mapping uses SetName`

**DERIVED FIELD DISPLAY EXAMPLES:**
```lpl
Derived Fields
	AccountStatus		is a DerivedField
		type is Alpha size 10
			if (Balance > 0)
				return "Active"
			else
				return "Inactive"
	
	FormattedAccountCode	is a DerivedField
		type is Alpha size 20
			return Company + "-" + AccountCode[1:6]
	
	IsValidAccount		is a DerivedField
		type is Boolean
			return AccountCode[1:1] matches "^[1-9]$" and AccountCode[2:2] matches "^[0-9]$"
```

=== FIELD RULES ===
- Validation logic for fields
- Constraints with error messages
- Conditional requirements based on other fields
- Default value assignments
- Regular expression validation
- "restricted" attribute for computed/calculated fields (CANNOT be used in Persistent Fields)
- Provide comprehensive data validation with conditional logic, default values, and error messages
- Syntax supports conditional validation, default assignments, constraint checking, and dynamic error messages

**IMPORTANT SYNTAX RULE:**
- "restricted" attribute can ONLY be applied in Field Rules section, NOT in Persistent Fields section
- Use Field Rules to restrict access to computed or calculated persistent fields

=== CSV IMPORT PROCESSING PATTERNS ===

**Business Class Design for CSV Import:**
- Map CSV columns directly to Persistent Fields
- Use appropriate data types based on content analysis
- Size Alpha fields based on maximum expected content length
- Include sorting sets for data retrieval and processing
- Implement standard CRUD actions for data management

**Common CSV Field Mappings:**
- company -> Company (Numeric 4)
- identifiers -> Numeric fields with appropriate sizing
- codes -> Alpha fields with size limits
- descriptions/comments -> Alpha fields with larger sizes
- dates -> Date fields (when in proper format)
- amounts -> Numeric fields with decimal precision

**CSV BUSINESS CLASS GENERATION PATTERNS:**
Based on Purchase Order Receipt Import CSV analysis:
- Header business class (cfgPurchaseOrderReceiptImport) maps PORI CSV structure
- Line business class (cfgPurchaseOrderReceiptLineImport) maps PORL CSV structure
- Field sizing based on actual data content analysis
- Relations between header and line records for data integrity
- Set Actions for batch processing by RunGroup and Company parameters
- Multiple sort orders for efficient data retrieval and processing

**FIELD SIZING ANALYSIS FROM CSV DATA:**
- Company: Numeric 4 (supports 4-digit company codes like 3020)
- Identifiers: Alpha 15 (accommodates 11+ character PO numbers like 30200000349)
- RunGroup: Alpha 20 (supports various naming conventions like SANR, SANU)
- Location: Alpha 10 (handles 6+ character location codes like GS0071)
- Quantities/Costs: Numeric 12 (supports large values with decimals)
- UOM: Alpha 5 (accommodates standard unit codes like BX)
- Comments: Alpha 100 (sufficient for integration timestamps and messages)

**CSV PROCESSING WORKFLOW SUPPORT:**
- RunGroup parameter enables file-specific batch processing
- Company parameter supports multi-entity operations
- Set Actions enable efficient batch processing as required by interfaces
- Relations support data validation and integrity checks between header and line records

=== PATTERNS ===
- Reusable implementations (e.g., "implements BODId")
- Provide common functionality across classes

=== ONTOLOGY ===
- Defines symbolic keys for entity identification
- Links to business meaning and relationships

=== PERSISTENT FIELDS SYNTAX ===
- Section starts with "Persistent Fields" followed by field definitions
- Field syntax: "FieldName is [a/an] DataType [size specification]"
- Indentation: Fields use tab indentation for hierarchy
- Data types: Alpha, Numeric, Boolean, Date, Text, Description, Decimal, XMLDocument
- Size specifications: "size N", "up to N", or just "N" after type
- Reference types: "is a BusinessClassName" or "is an BusinessClassName"
- Group types: "is a BusinessClassName group"
- Articles: Use "a" or "an" before reference types based on grammar
- Field ordering: No specific order required within Persistent Fields section

=== FIELD ATTRIBUTES ===
- "required" - mandatory field (ONLY used in Field Rules section, NOT in Persistent Fields)
- "holds pii" - contains personally identifiable information (used in Persistent Fields)
- "delete ignored" - prevents deletion (used in Persistent Fields)
- "translatable" - supports multiple languages (used in Persistent Fields)
- "disable Auditing" - excludes from audit trail (used in Persistent Fields)
- "default label" - UI display override (used in Persistent Fields)
- "restricted" - limited access/computed field (ONLY used in Field Rules section, NOT in Persistent Fields)

**CRITICAL SYNTAX RULE:**
- "required" and "restricted" attributes can ONLY be applied in Field Rules section
- Persistent Fields section should contain ONLY field definitions with data types and allowed attributes (holds pii, delete ignored, translatable, disable Auditing, default label)

=== LPL SYNTAX GENERATION IMPROVEMENTS ===

**MISSING CRITICAL COMPONENTS:**

**1. Validation & Constraint Syntax:**
- Field validation patterns (regex, range, custom validation)
- Cross-field validation rules and dependencies
- Conditional constraints with dynamic error messages
- Business rule validation blocks and constraint groups
- Data integrity enforcement patterns

**2. Advanced Field Features:**
- Computed field expressions with complex formulas
- Field dependencies and cascading update logic
- Dynamic field visibility and editability rules
- Field-level security and access control patterns
- Conditional field requirements based on context

**3. User Interface Definitions:**
- Form layouts and field positioning syntax
- List views and grid configuration patterns
- Navigation and menu structure definitions
- Report and dashboard layout specifications
- Mobile-responsive UI patterns

**4. Integration Patterns:**
- BOD (Business Object Document) mapping syntax
- Web service interface definitions and endpoints
- Database integration and stored procedure calls
- External system connectors and API integrations
- Message queue and event processing patterns

**5. Security & Authorization:**
- Role-based access control (RBAC) patterns
- Field-level security definitions and restrictions
- Action-level permissions and user context validation
- Data filtering by user roles and organizational hierarchy
- Audit trail and compliance tracking patterns

**SYNTAX PATTERN IMPROVEMENTS:**

**1. Enhanced Action Syntax:**
```lpl
// Background processing and error handling
ActionName is an Instance Action
    run in background
    resume on error
    transaction isolation level is READ_COMMITTED
    timeout is 300 seconds
    retry count is 3
    retry delay is 30 seconds
    on error
        send email to Administrator.EmailAddress
        log error to SystemLog
    on success
        update ProcessingStatus = "Completed"
```

**2. Advanced Relation Patterns:**
```lpl
// Conditional relations with dynamic filtering
RelationName
    one-to-many relation to TargetClass
    Field Mapping uses SetName
        related.Field1 = LocalField1
        related.Field2 = LocalField2
    Instance Selection
        where (related.Status = "Active"
        and   related.EffectiveDate <= current date
        and   related.Company = actor.context.Company)
    Cache Strategy is LAZY_LOAD
    Fetch Size is 100
    Order By related.Priority descending, related.CreateDate
```

**3. Complex Derived Field Logic:**
```lpl
// Multi-step calculations with error handling
DerivedFieldName is a DerivedField
    type is Alpha size 50
    restricted
    Local Fields
        LocalTemp is Alpha size 20
        LocalResult is Alpha size 50
    Calculations
        try
            LocalTemp = SourceField[1:10] uppercase
            if (LocalTemp matches "^[A-Z]{3}[0-9]{3}$")
                LocalResult = LocalTemp + "-VALID"
            else
                LocalResult = "INVALID-FORMAT"
        catch
            LocalResult = "PROCESSING-ERROR"
        return LocalResult
```

**4. Advanced Field Rules:**
```lpl
// Complex validation with conditional logic
Field Rules
    FieldName
        required when (Status = "Active")
        constraint (FieldName matches "^[A-Z0-9]{6,12}$")
            "FieldMustBe6To12AlphanumericCharacters"
        constraint (not DuplicateCheckRel exists)
            "DuplicateValueNotAllowed"
        on change
            invoke ValidateRelatedFields
            if (FieldNameChanged and Status = "Posted")
                constraint (false)
                    "CannotChangeFieldAfterPosting"
        default chain
            RelatedEntity.DefaultValue
            ConfigurationRel.DefaultSetting
            "DEFAULT"
```

**5. Enhanced Set Definitions:**
```lpl
// Advanced set with performance optimization
Sets
    AdvancedSet
        indexed
        unique
        cache size is 1000
        Sort Order
            Priority descending
            EffectiveDate
            ID
        Partition By Company
        Filter Condition
            where (Status in ("Active", "Pending")
            and   EffectiveDate <= current date)
```

**ENHANCED KNOWLEDGE AREAS NEEDED:**

**1. Error Handling Patterns:**
- Exception handling in actions and derived fields
- Validation error message formatting and localization
- Recovery procedures and automatic rollback logic
- Error logging and notification systems

**2. Performance Optimization:**
- Indexing strategies for sets and relations
- Caching mechanisms and cache invalidation
- Bulk processing patterns for large datasets
- Query optimization and execution plans

**3. Workflow Integration:**
- Approval process definitions and routing
- State machine patterns and transitions
- Event-driven processing and triggers
- Parallel processing and synchronization

**4. Data Migration Patterns:**
- Import/export configurations and mappings
- Data transformation rules and cleansing
- Legacy system integration patterns
- Incremental data synchronization

**5. Advanced Business Logic:**
- Complex calculation engines
- Rule-based decision making
- Dynamic configuration management
- Multi-tenant data isolation

**6. Testing and Debugging:**
- Unit test patterns for business classes
- Mock data generation for testing
- Debug logging and tracing capabilities
- Performance monitoring and profiling

**IMPLEMENTATION PRIORITIES:**
1. Complete validation and constraint syntax patterns
2. Advanced field calculation and dependency management
3. Comprehensive error handling and recovery mechanisms
4. Performance optimization patterns and best practices
5. Integration patterns for external systems and APIs
6. Security and authorization framework enhancements

=== SANFORD PURCHASE ORDER RECEIPT INTERFACE ANALYSIS ===

**DOCUMENT OVERVIEW:**
- Document: INT_003 Purchase Order Receipt Inbound Interface
- Author: Cherry Estrada (Initial), Julianne Sitoy (Updates)
- Version: 1.1 (Last Updated: 8/4/2025)
- Purpose: Interface between FSM and third-party systems (Niko Health, Made4Net, SC Logic)

**BUSINESS REQUIREMENTS:**
- **Frequency:** Every 20 minutes, 24/7 continuous processing
- **Source Systems:** Niko Health, Made4Net, SC Logic
- **Target System:** Infor FSM (Finance and Supply Management)
- **File Format:** CSV pipe-delimited
- **Transport:** SFTP repository maintained by Sanford

**INTERFACE COMPONENTS:**
1. **Header File (PORI):** PurchaseOrderReceiptImport business class
2. **Line File (PORL):** PurchaseOrderReceiptLineImport business class
3. **Detail File (PORD):** POReceiptInventoryDetailImport business class (Optional)

**FILE NAMING CONVENTIONS:**
- **Header:** PORI_<3rd Party System>_xxx.csv
- **Line:** PORL_<3rd Party System>_xxx.csv
- **Detail:** PORD_<3rd Party System>_xxx.csv (Optional)
- **Third Party Codes:** M4NS (Made4Net Shipment), M4NR (Made4Net Receipt), SCLO (SC Logic), NIKO (Niko Health)

**SFTP DIRECTORY STRUCTURE:**
- **Input:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/
- **Archive:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/Archive
- **Error:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/Error

**BUSINESS PROCESS FLOW:**
1. Third-party systems drop files to SFTP every 20 minutes
2. IPA processes files to update PO Lines (EXT29 reference)
3. IPA imports PO receipts into import business classes
4. IPA triggers interface action with criteria: RunGroup, Company
5. Records become available in Manage Purchase Order Receipts

**FIELD MAPPINGS IDENTIFIED:**

**PurchaseOrderReceiptImport Fields:**
- Company (Default mapping)
- PurchaseOrderReceiptImport (Interface identifier)
- RunGroup (File name reference)
- InterfacedPurchaseOrder (Same as PurchaseOrderReceiptImport)
- Reference Number, BillOfLanding, ReceiptComments

**PurchaseOrderReceiptLineImport Fields:**
- Company, PurchaseOrderReceiptImport, LineNumber, RunGroup
- SequenceNumber (FSM Item number)
- Location (FSM ItemLocation)
- EnteredReceivedQuantity, ReceivedUOM, OriginalUnitCost
- CancelBackorder, RecComments

**POReceiptInventoryDetailImport Fields (Optional):**
- Company, PurchaseOrderReceiptImport, LineNumber, SequenceNumber
- RunGroup, Serial, Lot, Quantity, LotExpirationDate

**ERROR HANDLING & NOTIFICATIONS:**
- Consolidated error reporting after processing
- Email notifications to TBD recipients
- Error file generation in designated SFTP error directory
- Multiple error scenarios covered (Import Failed, File Not Found, Async Trigger Failed)

**INTERFACE PARAMETERS:**
- Run Group: Purchase Order Receipt Import (File Name)
- Release Receipt: Default = No
- Release Option: Receive and Deliver
- Various configuration options for dropship, item matching, error handling

**KEY BUSINESS RULES:**
- Header and Line files can be processed independently
- Detail file is optional for serial/lot controlled items
- Existing PO detail records retained if no Detail file provided
- PO not updated if no existing details but Detail file provided
- Validation checks ensure data quality before FSM integration

**TECHNICAL SPECIFICATIONS:**
- Automated process flow for file consumption
- Background processing with error recovery
- Integration with existing FSM business classes
- Support for multi-entity processing (Company-based)

**INTEGRATION PATTERNS FOR LPL:**
This analysis provides insights for LPL business class design patterns:
- Import business class structures for external data integration
- File-based interface processing workflows
- Error handling and notification systems
- Multi-file processing with optional components
- SFTP-based data exchange patterns
- Automated scheduling and background processing
- Field mapping strategies for external system integration

**GENERATED BUSINESS CLASSES:**

**cfgPurchaseOrderReceiptImport (Header):**
- Company (Numeric 4) - Default company mapping
- PurchaseOrderReceiptImport (Alpha 15) - Interface identifier
- RunGroup (Alpha 20) - File name reference for processing
- PurchaseOrder (Alpha 15) - Purchase order reference
- BillOfLading (Alpha 20) - Bill of lading information
- ReceiptComments (Alpha 100) - Receipt comments
- ProcessReceipts Set Action for batch processing by RunGroup and Company

**cfgPurchaseOrderReceiptLineImport (Line):**
- Company (Numeric 4) - Default company mapping
- PurchaseOrderReceiptImport (Alpha 15) - Links to header record
- LineNumber (Numeric 3) - Line sequence number
- SequenceNumber (Numeric 3) - FSM item sequence number
- RunGroup (Alpha 20) - File name reference for processing
- Location (Alpha 10) - FSM item location
- EnteredReceivedQuantity (Numeric 12) - Received quantity
- ReceivedUOM (Alpha 5) - Unit of measure
- OriginalUnitCost (Numeric 12) - Unit cost
- CancelBackorder (Boolean) - Backorder cancellation flag
- RecComments (Alpha 100) - Receipt comments
- Relation to header business class for data integrity
- ProcessLineReceipts Set Action for batch processing

**CSV FIELD MAPPING ANALYSIS:**
Based on sample files PORI_M4NS_1234_20250814.csv and PORL_M4NS_1234_20250814.csv:
- Pipe-delimited format with header row
- Company values: 3020 (4-digit numeric)
- RunGroup values: SANR, SANU (4-character codes)
- Purchase order numbers: 30200000349, 30200000350 (11-digit format)
- Location codes: GS0071 (6-character alphanumeric)
- Quantities: 150, 30 (numeric values)
- UOM: BX (2-character unit codes)
- Unit costs: 32, 30 (numeric values)
- Boolean flags: 0 (false for CancelBackorder)

=== PURCHASE ORDER RECEIPT IMPORT BUSINESS CLASS PATTERNS ===

**IMPORT BUSINESS CLASS DESIGN:**
- Prefix naming convention: PORI (header), PORL (line)
- Company-based multi-entity support
- RunGroup field for batch processing identification
- Set Actions with parameter-driven filtering
- Symbolic key relations between header and line records

**FIELD SIZING ANALYSIS:**
- Company: Numeric 4 (supports 4-digit company codes)
- Identifiers: Alpha 15 (accommodates 11+ character PO numbers)
- RunGroup: Alpha 20 (supports various naming conventions)
- Location: Alpha 10 (handles 6+ character location codes)
- Quantities/Costs: Numeric 12 (supports large values with decimals)
- UOM: Alpha 5 (accommodates standard unit codes)
- Comments: Alpha 100 (sufficient for integration timestamps and messages)

**PROCESSING PATTERNS:**
- Set Actions for batch processing by RunGroup and Company criteria
- Primary sort by Company and identifier fields
- Secondary sort by RunGroup for processing efficiency
- One-to-one relation from line to header for data integrity

=== SET IS SYNTAX ANALYSIS ===

**'Set Is' SYNTAX PATTERN:**
The 'Set Is' syntax is used within Set Actions to define the data set that the action will operate on. It appears in the GLTransactionDetail.busclass file as a way to specify which records should be included in the set action processing.

**SYNTAX STRUCTURE:**
```lpl
ActionName is a Set Action
    Parameters
        // Parameter definitions
    Instance Selection
        where (conditions)
    Set Is
        ParameterName
    Sort Order
        // Sort fields
    Action Rules
        // Processing logic
```

**IDENTIFIED USAGE PATTERNS:**

1. **CreateDetailsForJournalTransaction Set Action:**
```lpl
CreateDetailsForJournalTransaction is a Set Action
    restricted
    Parameters
        PrmRelatedJournalTransaction is BusinessObjectReference
    Set Is
        PrmRelatedJournalTransaction
    Instance Selection
        where (RelatedJournalTransaction.BusinessClassName = PrmRelatedJournalTransaction.BusinessClassName
        and   RelatedJournalTransaction.BusinessObjectKey = PrmRelatedJournalTransaction.BusinessObjectKey)
```

2. **BuildProcurementExpenseRecords Set Action:**
```lpl
BuildProcurementExpenseRecords is a Set Action
    restricted
    Instance Selection
        where ((JournalizeGroup entered
        and    Status = Status.History
        and   !GLProcurementExpenseRel exists)
        and   (System = "AP"
        or     System = "IC"
        or     System = "RQ"
        or     System = "PO"))
    Set Is
        // Empty Set Is declaration
    Sort Order is ByJournalizeGroup
```

**KEY CHARACTERISTICS:**
- **Purpose**: Defines the parameter or field that determines the set grouping for the action
- **Position**: Appears after Parameters and Instance Selection, before Sort Order
- **Usage**: Can reference a parameter name or be left empty
- **Function**: Controls how records are grouped during set action processing

**FUNCTIONAL BEHAVIOR:**
- When 'Set Is' references a parameter, records are grouped by that parameter's value
- Empty 'Set Is' declarations indicate no specific grouping parameter
- Used in conjunction with Instance Selection to filter and group records
- Affects how Action Rules are applied to the selected record set

**BUSINESS LOGIC INTEGRATION:**
- Enables batch processing of related records
- Supports complex transaction processing workflows
- Facilitates data aggregation and summarization
- Allows for parameter-driven record grouping

**ADVANCED PATTERNS:**
- Can be combined with Accumulators for set-level calculations
- Works with Sort Order to control processing sequence
- Supports nested Set Rules for hierarchical processing
- Integrates with Instance Selection for complex filtering logic

**GLTRANSACTIONDETAIL KEY LEARNINGS:**
1. **Conditional Compilation:** Use #ifdef/#endif for module-specific functionality
2. **Complex Derived Fields:** Support multi-step conditional logic with business class name checking
3. **Advanced Relations:** Implement complex field mappings with instance selection filtering
4. **Currency Processing:** Handle multi-currency scenarios with automatic conversion
5. **Inter-Entity Processing:** Create balancing entries across multiple accounting entities
6. **Zone Balancing:** Implement advanced zone accounting for organizational structures
7. **Set Actions:** Use complex set actions for batch processing with parameter validation
8. **Rule Blocks:** Implement multi-step rule blocks for complex business logic
9. **Field Attributes:** Use specialized attributes for audit control and system integration
10. **Business Object References:** Implement typed references for cross-entity relationships

=== DETAIL SECTIONS SYNTAX ===

**OVERVIEW:**
Detail Sections is a List syntax construct that defines tabbed or sectioned views within a list interface, enabling organized display of related data, forms, and sub-lists with conditional visibility and advanced layout options.

**BASIC SYNTAX STRUCTURE:**
```lpl
ListName is a List
    title is "ListTitle"
    Display Fields
        // Field definitions
    Detail Sections
        SectionName
            title is "SectionTitle"
            visible when (condition)
            list is RelationName.ListName
        FormSection
            form is FormName
        MultiViewSection is a MultiListView
            Detail Sections
                // Nested sections
```

**DETAIL SECTIONS COMPONENTS:**

**1. BASIC SECTION TYPES:**
- **List Sections:** Display related records using relations
- **Form Sections:** Show detailed forms for current record
- **Multi-List Views:** Container for multiple related lists
- **Dashboard Views:** Grid-based layout with column spanning

**2. SECTION ATTRIBUTES:**
- **title:** Display label for the section tab
- **visible when:** Conditional visibility based on field values
- **list:** Reference to relation and specific list view
- **form:** Reference to form definition for display
- **span N columns:** Column width in dashboard views (1-12)

**3. ADVANCED LAYOUT OPTIONS:**
- **MultiListView:** Container for multiple related sections
- **DashBoardView:** Grid-based layout with column control
- **use 12 column grid:** Enable responsive grid layout
- **show single panel tab:** Display only one section at a time
- **allow nested detail sections:** Enable hierarchical section nesting

**SYNTAX PATTERNS:**

**1. SIMPLE LIST SECTION:**
```lpl
Detail Sections
    LogDataDetail
        title is "LogDetails"
        list is LogDataDetailRel.LogDataDetailList
```

**2. CONDITIONAL VISIBILITY:**
```lpl
Detail Sections
    YesNoDetails
        visible when (ResponseType.YesNo)
        list is QuestionAnswer set.QuestionYesNoAnswers
    ListDetails
        visible when (ResponseType.List)
        list is QuestionAnswer set.QuestionListAnswers
```

**3. FORM SECTIONS:**
```lpl
Detail Sections
    Details
        form is DetailsForm
    Summary
        form is Summary
```

**4. MULTI-LIST VIEW WITH NESTED SECTIONS:**
```lpl
Detail Sections
    Recommendations is a MultiListView
        visible when (IsPerpetualLocation)
        Detail Sections
            KPIList
                list is IIHItemLocation.KpiList
            Recommendation
                list is IIHItemLocation.ItemDetailRecommendationGridViewList
            DailyDataChart
                visible when (not FillGraphGaps)
                list is IIHDailyDataRel.DailyTransactionChartView
```

**5. DASHBOARD VIEW WITH COLUMN SPANNING:**
```lpl
Detail Sections
    Information is a DashBoardView
        use 12 column grid
        Detail Sections
            Specifications
                span 4 columns
                form is Specifications
            Reference
                span 4 columns
                form is Reference
            ItemInformation
                span 3 columns
                form is IIHItemLocation.GeneralStatistics
```

**6. HELPER LISTS WITH ACTIONS:**
```lpl
Detail Sections
    AssetAdjustment
        title is "Adjustments"
        visible when (ShowMassSelectionAdjustment)
        list is MassSelectionDetailsRel.MassAdjustmentSelections
            helper list is AssetsForAdjustmentRel.AssetsForSelectionHelper
                action is IncludeInMassSelection
```

**ADVANCED FEATURES:**

**1. NESTED DETAIL SECTIONS:**
- Support hierarchical organization of related data
- Enable complex multi-level navigation structures
- Allow conditional display at multiple levels

**2. RESPONSIVE GRID LAYOUT:**
- 12-column grid system for flexible layouts
- Column spanning for different section widths
- Responsive design adaptation

**3. CONDITIONAL VISIBILITY:**
- Field-based conditional display logic
- Complex boolean expressions for visibility
- Dynamic section showing/hiding based on data state

**4. HELPER LISTS:**
- Secondary lists for selection and action operations
- Integration with primary list data
- Action buttons for data manipulation

**5. SINGLE PANEL TABS:**
- Exclusive section display (only one visible at a time)
- Tab-based navigation between sections
- Optimized for focused data viewing

**BUSINESS USE CASES:**

**1. MASTER-DETAIL INTERFACES:**
- Header record with multiple detail sections
- Related transaction displays
- Document line item management

**2. DASHBOARD LAYOUTS:**
- KPI and metrics display
- Multi-section information panels
- Responsive business intelligence views

**3. WORKFLOW INTERFACES:**
- Step-based process navigation
- Conditional section availability
- Progress-driven section display

**4. ANALYSIS AND REPORTING:**
- Multi-dimensional data views
- Chart and graph integration
- Drill-down capability through sections

**IMPLEMENTATION BEST PRACTICES:**

**1. SECTION ORGANIZATION:**
- Group related functionality logically
- Use descriptive section titles
- Implement consistent visibility patterns

**2. PERFORMANCE OPTIMIZATION:**
- Use conditional visibility to reduce data loading
- Implement efficient relation queries
- Consider lazy loading for large datasets

**3. USER EXPERIENCE:**
- Provide clear navigation between sections
- Use appropriate layout types for content
- Implement responsive design principles

**4. DATA INTEGRITY:**
- Ensure proper relation definitions
- Validate conditional logic thoroughly
- Test section interactions comprehensively

**COMMON PATTERNS:**

**1. TRANSLATION LISTS:**
- Standard Detail Sections for multi-language support
- Form-based translation interfaces
- Language-specific section visibility

**2. IMPORT/EXPORT INTERFACES:**
- Detail sections for processing results
- Error and success message displays
- File processing status sections

**3. FINANCIAL TRANSACTION VIEWS:**
- Header-line-distribution hierarchies
- Multi-currency display sections
- Audit trail and history sections

**4. INVENTORY AND ASSET MANAGEMENT:**
- Location-based detail sections
- Serial/lot tracking displays
- Movement history and analytics

**INTEGRATION WITH OTHER LPL CONSTRUCTS:**
- **Relations:** Provide data sources for list sections
- **Forms:** Define section content and layout
- **Actions:** Enable section-specific operations
- **Conditions:** Control section visibility and behavior
- **Sets:** Organize and filter section data

=== INTERFACE BUSINESS CLASS BEST PRACTICES ===

**NAMING CONVENTIONS:**
- Use 'cfg' prefix for business classes as specified in rules
- Descriptive field names matching source system terminology
- Consistent naming between related business classes

**DATA INTEGRITY:**
- Relations between header and line records
- Symbolic key mapping for standard field connections
- Appropriate field sizing based on sample data analysis

**PROCESSING EFFICIENCY:**
- Set Actions with parameter filtering for batch operations
- Multiple sort orders for different processing scenarios
- RunGroup-based processing for file-specific operations

**FIELD TYPE SELECTION:**
- Numeric fields for company codes, quantities, and costs
- Alpha fields for identifiers, codes, and comments
- Boolean fields for flags and indicators
- Appropriate sizing based on actual data requirements

=== CREATE ACTION SYNTAX ===

**CREATE ACTION DEFINITION:**
- Syntax: "ActionName is a Create Action"
- Used to create new records in a business class
- Enables record creation functionality within LPL business classes
- Standard action type for data insertion operations

**BASIC CREATE ACTION PATTERN:**
```lpl
CreateActionName is a Create Action
    // Action logic and rules
```

=== UPDATE ACTION SYNTAX ===

**UPDATE ACTION DEFINITION:**
- Syntax: "ActionName is an Update Action"
- Used to update existing records in a business class
- Enables record modification functionality within LPL business classes
- Standard action type for data modification operations

**BASIC UPDATE ACTION PATTERN:**
```lpl
UpdateActionName is an Update Action
    // Action logic and rules
```

=== DELETE ACTION SYNTAX ===

**DELETE ACTION DEFINITION:**
- Syntax: "ActionName is a Delete Action"
- Used to logically delete records from a business class
- Enables record deletion functionality within LPL business classes
- Standard action type for data removal operations

**BASIC DELETE ACTION PATTERN:**
```lpl
DeleteActionName is a Delete Action
    // Action logic and rules
```

=== PURGE ACTION SYNTAX ===

**PURGE ACTION DEFINITION:**
- Syntax: "ActionName is a Purge Action"
- Used to permanently delete all traces of records from a business class
- Enables complete record removal functionality within LPL business classes
- Standard action type for permanent data removal operations
- Compared to Delete actions that maintain logical trails, Purge actions remove all traces

**BASIC PURGE ACTION PATTERN:**
```lpl
PurgeActionName is a Purge Action
    // Action logic and rules
```

=== USER INTERACTION PATTERNS ===

**GREETING RESPONSES:**
- Users may greet with informal terms like "Hayup" (Filipino greeting)
- Respond professionally while acknowledging the greeting
- Immediately offer LPL assistance and available services
- Maintain focus on LPL development tasks

=== SANFORD INTERFACE IMPLEMENTATION NOTES ===

**BUSINESS CLASS GENERATION COMPLETED:**
1. **cfgPurchaseOrderReceiptImport** - Header business class for PORI files
2. **cfgPurchaseOrderReceiptLineImport** - Line business class for PORL files

**KEY IMPLEMENTATION FEATURES:**
- Field mappings based on actual CSV sample data structure
- Appropriate data types and sizes for all fields
- Relations between header and line records for data integrity
- Set Actions for batch processing by RunGroup and Company
- Multiple sort orders for efficient data retrieval
- Standard CRUD actions for data management

**SAMPLE DATA ANALYSIS:**
- Company: 3020 (4-digit numeric format)
- Purchase Orders: 30200000349, 30200000350 (11-digit format)
- RunGroups: SANR, SANU (4-character processing codes)
- Locations: GS0071 (6-character location codes)
- Quantities: 150, 30 (whole numbers)
- UOM: BX (2-character unit codes)
- Unit Costs: 32, 30 (numeric values)
- Comments: Timestamped integration messages

**PROCESSING WORKFLOW SUPPORT:**
- RunGroup parameter for file-specific processing
- Company parameter for multi-entity operations
- Set Actions enable batch processing as required
- Relations support data validation and integrity checks

=== GLTRANSACTIONDETAIL BUSINESS CLASS ANALYSIS ===

**COMPREHENSIVE BUSINESS CLASS STRUCTURE:**
Analyzed GLTransactionDetail.busclass - a complex financial transaction processing business class with extensive field types, relations, and business logic.

**ADVANCED FIELD TYPES IDENTIFIED:**
1. **Context Fields with Conditional Compilation:**
   - Uses #ifdef module directives for conditional field inclusion
   - Module-specific fields (ap, intercobilling, am, po)
   - Search and filter context fields for complex queries

2. **Complex Persistent Fields:**
   - Status fields with enumerated states (Unreleased=0, Released=1, NotToBePosted=8, History=9)
   - Multiple currency and amount fields (TransactionAmount, ReportCurrencyAmount)
   - Reference fields to other business classes (FinanceCodeBlock, AccountingEntity)
   - Specialized data types (ExchangeDate, CurrencyAmount, BusinessObjectReference)

3. **Advanced Derived Fields with Complex Logic:**
   - Multi-step conditional calculations
   - String manipulation and concatenation
   - Substring extraction with one-based indexing
   - Business rule validation and formatting
   - Cross-module field derivation based on OriginatingTransaction.BusinessClassName

**DERIVED FIELD PATTERNS:**
```lpl
// Complex conditional derivation
DerivedCompany is a DerivedField
    type is like Company
    if (OriginatingTransaction.BusinessClassName = "PayablesInvoiceDistribution")
        return OriginatingTransaction(PayablesInvoiceDistribution).PayablesInvoice.Company
    else
        if (OriginatingTransaction.BusinessClassName = "InventoryTransactionLineDistribution")

=== CSV-BASED BUSINESS CLASS GENERATION COMPLETED ===

**GENERATED BUSINESS CLASSES:**
Successfully created header and line business classes based on CSV analysis:

1. **cfgPurchaseOrderReceiptImport** (Header Business Class)
   - Maps PORI CSV structure with pipe-delimited fields
   - Company (Numeric 4), PurchaseOrderReceiptImport (Alpha 15), RunGroup (Alpha 20)
   - PurchaseOrder (Alpha 15), BillOfLading (Alpha 20), ReceiptComments (Alpha 100)
   - Set Actions for batch processing by RunGroup and Company parameters
   - Multiple sort orders for efficient data retrieval

2. **cfgPurchaseOrderReceiptLineImport** (Line Business Class)
   - Maps PORL CSV structure with detailed line information
   - Company (Numeric 4), LineNumber (Numeric 3), SequenceNumber (Numeric 3)
   - Location (Alpha 10), EnteredReceivedQuantity (Numeric 12), ReceivedUOM (Alpha 5)
   - OriginalUnitCost (Numeric 12), CancelBackorder (Boolean), RecComments (Alpha 100)
   - One-to-one relation to header business class for data integrity
   - Set Actions for batch line processing

**FIELD SIZING BASED ON ACTUAL DATA:**
- Company: 3020 (4-digit numeric) → Numeric 4
- Purchase Orders: 30200000349 (11-digit) → Alpha 15
- RunGroups: SANR, SANU (4-character) → Alpha 20
- Location: GS0071 (6-character) → Alpha 10
- Quantities: 150, 30 → Numeric 12
- UOM: BX (2-character) → Alpha 5
- Unit Costs: 32, 30 → Numeric 12
- Comments: Integration timestamps → Alpha 100

**PROCESSING PATTERNS IMPLEMENTED:**
- RunGroup-based batch processing for file identification
- Company-based multi-entity support
- Symbolic key relations between header and line records
- Standard CRUD actions for data management
- Multiple sort orders for processing efficiency

=== ACTION SYNTAX CORRECTIONS ===

**CORRECT ACTION SYNTAX:**
- Create is a Create Action (for new record creation)
- Update is an Update Action (for record modification)
- Delete is a Delete Action (for record deletion)
- Inquire is an Instance Action (for record viewing)

**IMPORTANT:** Use proper action types - "Create is a Create Action" for creation, "Update is an Update Action" for modification, "Delete is a Delete Action" for deletion.
LANDMARK PROGRAMMING LANGUAGE (LPL) KNOWLEDGE BASE
Author: Kyle Alrich Alonzo
Birthday: July 19, 1996
Company: Infor
Created: August 19, 2025

=== INSTRUCTIONS FOR THE AI ===
Amazon Q will follow these instructions without fail when this file is referenced as context:
1. Strictly update '\lpl-library\Knowledge.txt' with knowledge learned related to Landmark Programming Language every response.
2. Use the subdirectory '\lpl-library\Programs\' for the python scripts.
3. Use the subdirectory '\lpl-library\References\' as source of knowledge and learn.
4. Use the subdirectory '\lpl-library\Inputs\' as source of input data.
5. Use the subdirectory '\lpl-library\Others\' to store supporting output files used by the python program.
6. Use the subdirectory '\lpl-library\Outputs\' for the generated files.
7. After every response, display a random LPL tip.
8. Always use the prefix 'cfg' when asked to generate a business class.
9. Automatically commit all changes to the repository after every response using Git commands.
Format: ***LPL Tip:** User Interface Definition syntax enables creation of rich, interactive user interfaces with comprehensive form layouts, list views, card displays, charts, and responsive design elements, supporting complex business workflows and data visualization requirements.*

=== DIRECTORY STRUCTURE UPDATE ===
- Use '\Outputs\' for generated files
- All future generated files will be placed in Outputs subdirectory

=== BUSINESS CLASS STRUCTURE ===
- BusinessClass is a core LPL construct for defining business entities
- Syntax: "ClassName is a BusinessClass"
- Owned by parent entities (e.g., "owned by GeneralLedger")
- Has prefix for identification (e.g., "prefix is GLACC")
- Representative text format for display

=== FIELD TYPES ===
1. Context Fields - conditional compilation with #ifdef
2. Persistent Fields - stored data with types:
   - Numeric (with size specification)
   - Boolean
   - Alpha (with size limits)
   - Description
   - Date
   - Text
3. Transient Fields - temporary/calculated fields
4. Local Fields - internal processing fields with sub-types:
   - Reference fields (e.g., LocalSystemAccount)
   - Derived fields with complex logic
   - Set relations for data collections
   - Message fields for UI feedback
   - Configuration and error handling fields
5. Derived Fields - computed values with logic

=== DATA TYPES ===
- Numeric [size] - numbers with specified precision
- Boolean - true/false values
- Alpha [size] - text strings with character limits
- Date - date values
- Text - longer text content
- XMLDocument - XML data structures

=== FIELD STATES ===
Fields can have enumerated states with values:
- States block defines named constants
- Each state has a name and numeric value
- Example: BalanceSheet value is 1, IncomeStatement value is 2

=== FIELD ATTRIBUTES ===
- "required" - mandatory fields
- "restricted" - limited access/computed fields
- "holds pii" - contains personally identifiable information
- "default label" - UI display label
- "delete ignored" - prevents deletion

=== DERIVED FIELDS ===
- Computed fields with conditional logic that calculate values dynamically
- Not stored in database - calculated on-demand when accessed
- Use separate if/else blocks for calculations and business logic (NOT inline ternary expressions)
- Can reference other fields, relations, and complex expressions
- Support string manipulation, concatenation, and mathematical operations
- Return typed values (Alpha, Boolean, Numeric, Date)
- Substring syntax: field[startIndex:endIndex] extracts portions of text fields
- One-based indexing: [1:6] returns first 6 characters (positions 1-6)
- EndIndex is inclusive in range notation
- Single character extraction: field[6:6] gets the 6th character (position 6)
- String comparison operators (>=, <=) work for numeric character validation
- RegEx pattern matching: field matches "pattern" for validation
- Common patterns: "^[0-9]$" for single digit, "^[A-Z]+$" for uppercase letters
- Character position validation: SourceField[6:6] matches "^[0-9]$" checks if 6th character is numeric
- Regex group extraction: field matches "pattern" group N extracts captured groups from regex patterns
- Comma-separated parsing: "^[0-9]+,\\s*([0-9]+),\\s*[0-9]+$" group 1 extracts second number
- 'restricted' attribute should only be used when explicitly specified by the user
- Common use cases: display formatting, status calculations, data validation, business rules
- Support nested conditional logic and complex mathematical expressions
- Can combine multiple fields and perform string concatenation with + operator

**EMPLOYEE NAME DERIVED FIELD EXAMPLE:**
```lpl
Derived Fields
	EmployeeName		is a DerivedField
		type is Alpha size 50
			if (LastName entered and FirstName entered)
				return LastName + ", " + FirstName
			if (LastName entered)
				return LastName
			if (FirstName entered)
				return FirstName
			else
				return "Unknown Employee"
```


**CORRECT DERIVED FIELD CONDITIONAL SYNTAX:**
```lpl
DerivedFieldName		is a DerivedField
	type is Alpha size 20
		if (Condition1)
			return "Value1"
		if (Condition2)
			return "Value2"
		else
			return "DefaultValue"
```

**INCORRECT SYNTAX (DO NOT USE):**
```lpl
// Wrong - inline ternary expressions not supported
return if (condition) then value1 else value2
```

**SUBSTRING EXTRACTION EXAMPLES:**
```lpl
Derived Fields
	FirstSixDigits		is a DerivedField
		type is Alpha size 6
		return SourceField[1:6]
	
	FourthCharacter		is a DerivedField
		type is Alpha size 1
		return SourceField[4:4]
	
	FifthCharacterIsNumeric		is a DerivedField
		type is Boolean
		return SourceField[5:5] matches "^[0-9]$"
```

**DERIVED FIELD SUBSTRING EXTRACTION:**
- Syntax: FieldName[startIndex:endIndex] extracts character ranges
- One-based indexing: [1:6] returns positions 1 through 6
- EndIndex is inclusive in the range
- Commonly used for extracting prefixes, codes, or identifiers from larger fields

=== CONDITIONS ===
- Named boolean conditions for business logic
- Use "when" clauses with field comparisons
- Support logical operators (and, or, !)
- Can be "restricted" for internal use

=== RELATIONS ===
- Define relationships between business classes
- Types: one-to-one, one-to-many
- Field Mapping specifies how entities connect
- Instance Selection filters related records
- Support symbolic key and custom mappings

**Field Mapping Types:**
- **Symbolic Key:** Uses default/standard key fields of target business class
- **Custom Mappings:** Allows custom field sorting based on source business class field availability

**IMPORTANT: When generating relations, Amazon Q should ask the user which set will be used for the Field Mapping.**

**DEFAULT BEHAVIOR:** If the user doesn't provide a set, use 'symbolic key' by default. Amazon Q should then use the most important Persistent Fields of the Target Business Class to build the relation.

**IMPORTANT:** Even with symbolic key mapping, explicit field connections must be defined (e.g., related.PurchaseOrder = PurchaseOrder).

**RELATION CREATION PROCESS:**
When creating a Relation, Amazon Q should examine the target business class by searching its respective .busclass file in the References folder. The target business class file contains:
- The set that should be used for Field Mapping
- The list of fields that need to be mapped
- The proper field order and relationships

**IMPORTANT: After generating a relation, Amazon Q must ALWAYS ask the user for confirmation if the field mapping provided is correct.**

**Syntax Examples:**
```lpl
// Symbolic key mapping (uses target's default keys)
RelationName
	one-to-one relation to TargetEntity
	Field Mapping uses symbolic key

// Custom mapping (explicit field connections)
RelationName
	one-to-many relation to TargetEntity
	Field Mapping uses SortName
		related.TargetField1 = LocalField1
		related.TargetField2 = LocalField2
	Instance Selection
		where (related.Status = "Active")

// Real-world example: PurchaseOrder to PayablesInvoice
PayablesInvoiceRel
	one-to-many relation to PayablesInvoice
	Field Mapping uses symbolic key
		related.Company = Company
		related.PayablesInvoice = PayablesInvoice
```

=== SETS ===
- Collections of related data
- Can specify sort order
- Support duplicates or unique constraints

**SET RETRIEVAL PROCESS:**
When retrieving available Sets from a BusinessClass file:
1. Use `findstr /n "Sets"` to locate the Sets section line number
2. Extract content starting from the Sets section line
3. Look for "Sort Order is SetName" patterns in Set Actions
4. Search for explicit Set definitions in the Sets section
5. Check Relations sections for set references (e.g., "is a BusinessClass set")
6. Verify set existence by searching the entire file content

**IMPORTANT: If Amazon Q fails to retrieve a Set that the user has specified after thorough searching, ask the user to double-check the .busclass file in the References folder to verify if the set indeed exists.**

**SET IDENTIFICATION PATTERNS:**
- Direct Sets section: `SetName` followed by sort order or constraints
- Set Actions: `Sort Order is SetName`
- Relations: `RelationName is a BusinessClass set`
- Field Mapping: `Field Mapping uses SetName`

**DERIVED FIELD DISPLAY EXAMPLES:**
```lpl
Derived Fields
	AccountStatus		is a DerivedField
		type is Alpha size 10
			if (Balance > 0)
				return "Active"
			else
				return "Inactive"
	
	FormattedAccountCode	is a DerivedField
		type is Alpha size 20
			return Company + "-" + AccountCode[1:6]
	
	IsValidAccount		is a DerivedField
		type is Boolean
			return AccountCode[1:1] matches "^[1-9]$" and AccountCode[2:2] matches "^[0-9]$"
```

=== FIELD RULES ===
- Validation logic for fields
- Constraints with error messages
- Conditional requirements based on other fields
- Default value assignments
- Regular expression validation
- "restricted" attribute for computed/calculated fields (CANNOT be used in Persistent Fields)
- Provide comprehensive data validation with conditional logic, default values, and error messages
- Syntax supports conditional validation, default assignments, constraint checking, and dynamic error messages

**IMPORTANT SYNTAX RULE:**
- "restricted" attribute can ONLY be applied in Field Rules section, NOT in Persistent Fields section
- Use Field Rules to restrict access to computed or calculated persistent fields

=== CSV IMPORT PROCESSING PATTERNS ===

**Business Class Design for CSV Import:**
- Map CSV columns directly to Persistent Fields
- Use appropriate data types based on content analysis
- Size Alpha fields based on maximum expected content length
- Include sorting sets for data retrieval and processing
- Implement standard CRUD actions for data management

**Common CSV Field Mappings:**
- company -> Company (Numeric 4)
- identifiers -> Numeric fields with appropriate sizing
- codes -> Alpha fields with size limits
- descriptions/comments -> Alpha fields with larger sizes
- dates -> Date fields (when in proper format)
- amounts -> Numeric fields with decimal precision

**CSV BUSINESS CLASS GENERATION PATTERNS:**
Based on Purchase Order Receipt Import CSV analysis:
- Header business class (cfgPurchaseOrderReceiptImport) maps PORI CSV structure
- Line business class (cfgPurchaseOrderReceiptLineImport) maps PORL CSV structure
- Field sizing based on actual data content analysis
- Relations between header and line records for data integrity
- Set Actions for batch processing by RunGroup and Company parameters
- Multiple sort orders for efficient data retrieval and processing

**FIELD SIZING ANALYSIS FROM CSV DATA:**
- Company: Numeric 4 (supports 4-digit company codes like 3020)
- Identifiers: Alpha 15 (accommodates 11+ character PO numbers like 30200000349)
- RunGroup: Alpha 20 (supports various naming conventions like SANR, SANU)
- Location: Alpha 10 (handles 6+ character location codes like GS0071)
- Quantities/Costs: Numeric 12 (supports large values with decimals)
- UOM: Alpha 5 (accommodates standard unit codes like BX)
- Comments: Alpha 100 (sufficient for integration timestamps and messages)

**CSV PROCESSING WORKFLOW SUPPORT:**
- RunGroup parameter enables file-specific batch processing
- Company parameter supports multi-entity operations
- Set Actions enable efficient batch processing as required by interfaces
- Relations support data validation and integrity checks between header and line records

=== PATTERNS ===
- Reusable implementations (e.g., "implements BODId")
- Provide common functionality across classes

=== ONTOLOGY ===
- Defines symbolic keys for entity identification
- Links to business meaning and relationships

=== PERSISTENT FIELDS SYNTAX ===
- Section starts with "Persistent Fields" followed by field definitions
- Field syntax: "FieldName is [a/an] DataType [size specification]"
- Indentation: Fields use tab indentation for hierarchy
- Data types: Alpha, Numeric, Boolean, Date, Text, Description, Decimal, XMLDocument
- Size specifications: "size N", "up to N", or just "N" after type
- Reference types: "is a BusinessClassName" or "is an BusinessClassName"
- Group types: "is a BusinessClassName group"
- Articles: Use "a" or "an" before reference types based on grammar
- Field ordering: No specific order required within Persistent Fields section

=== FIELD ATTRIBUTES ===
- "required" - mandatory field (ONLY used in Field Rules section, NOT in Persistent Fields)
- "holds pii" - contains personally identifiable information (used in Persistent Fields)
- "delete ignored" - prevents deletion (used in Persistent Fields)
- "translatable" - supports multiple languages (used in Persistent Fields)
- "disable Auditing" - excludes from audit trail (used in Persistent Fields)
- "default label" - UI display override (used in Persistent Fields)
- "restricted" - limited access/computed field (ONLY used in Field Rules section, NOT in Persistent Fields)

**CRITICAL SYNTAX RULE:**
- "required" and "restricted" attributes can ONLY be applied in Field Rules section
- Persistent Fields section should contain ONLY field definitions with data types and allowed attributes (holds pii, delete ignored, translatable, disable Auditing, default label)

=== LPL SYNTAX GENERATION IMPROVEMENTS ===

**MISSING CRITICAL COMPONENTS:**

**1. Validation & Constraint Syntax:**
- Field validation patterns (regex, range, custom validation)
- Cross-field validation rules and dependencies
- Conditional constraints with dynamic error messages
- Business rule validation blocks and constraint groups
- Data integrity enforcement patterns

**2. Advanced Field Features:**
- Computed field expressions with complex formulas
- Field dependencies and cascading update logic
- Dynamic field visibility and editability rules
- Field-level security and access control patterns
- Conditional field requirements based on context

**3. User Interface Definitions:**
- Form layouts and field positioning syntax
- List views and grid configuration patterns
- Navigation and menu structure definitions
- Report and dashboard layout specifications
- Mobile-responsive UI patterns

**4. Integration Patterns:**
- BOD (Business Object Document) mapping syntax
- Web service interface definitions and endpoints
- Database integration and stored procedure calls
- External system connectors and API integrations
- Message queue and event processing patterns

**5. Security & Authorization:**
- Role-based access control (RBAC) patterns
- Field-level security definitions and restrictions
- Action-level permissions and user context validation
- Data filtering by user roles and organizational hierarchy
- Audit trail and compliance tracking patterns

**SYNTAX PATTERN IMPROVEMENTS:**

**1. Enhanced Action Syntax:**
```lpl
// Background processing and error handling
ActionName is an Instance Action
    run in background
    resume on error
    transaction isolation level is READ_COMMITTED
    timeout is 300 seconds
    retry count is 3
    retry delay is 30 seconds
    on error
        send email to Administrator.EmailAddress
        log error to SystemLog
    on success
        update ProcessingStatus = "Completed"
```

**2. Advanced Relation Patterns:**
```lpl
// Conditional relations with dynamic filtering
RelationName
    one-to-many relation to TargetClass
    Field Mapping uses SetName
        related.Field1 = LocalField1
        related.Field2 = LocalField2
    Instance Selection
        where (related.Status = "Active"
        and   related.EffectiveDate <= current date
        and   related.Company = actor.context.Company)
    Cache Strategy is LAZY_LOAD
    Fetch Size is 100
    Order By related.Priority descending, related.CreateDate
```

**3. Complex Derived Field Logic:**
```lpl
// Multi-step calculations with error handling
DerivedFieldName is a DerivedField
    type is Alpha size 50
    restricted
    Local Fields
        LocalTemp is Alpha size 20
        LocalResult is Alpha size 50
    Calculations
        try
            LocalTemp = SourceField[1:10] uppercase
            if (LocalTemp matches "^[A-Z]{3}[0-9]{3}$")
                LocalResult = LocalTemp + "-VALID"
            else
                LocalResult = "INVALID-FORMAT"
        catch
            LocalResult = "PROCESSING-ERROR"
        return LocalResult
```

**4. Advanced Field Rules:**
```lpl
// Complex validation with conditional logic
Field Rules
    FieldName
        required when (Status = "Active")
        constraint (FieldName matches "^[A-Z0-9]{6,12}$")
            "FieldMustBe6To12AlphanumericCharacters"
        constraint (not DuplicateCheckRel exists)
            "DuplicateValueNotAllowed"
        on change
            invoke ValidateRelatedFields
            if (FieldNameChanged and Status = "Posted")
                constraint (false)
                    "CannotChangeFieldAfterPosting"
        default chain
            RelatedEntity.DefaultValue
            ConfigurationRel.DefaultSetting
            "DEFAULT"
```

**5. Enhanced Set Definitions:**
```lpl
// Advanced set with performance optimization
Sets
    AdvancedSet
        indexed
        unique
        cache size is 1000
        Sort Order
            Priority descending
            EffectiveDate
            ID
        Partition By Company
        Filter Condition
            where (Status in ("Active", "Pending")
            and   EffectiveDate <= current date)
```

**ENHANCED KNOWLEDGE AREAS NEEDED:**

**1. Error Handling Patterns:**
- Exception handling in actions and derived fields
- Validation error message formatting and localization
- Recovery procedures and automatic rollback logic
- Error logging and notification systems

**2. Performance Optimization:**
- Indexing strategies for sets and relations
- Caching mechanisms and cache invalidation
- Bulk processing patterns for large datasets
- Query optimization and execution plans

**3. Workflow Integration:**
- Approval process definitions and routing
- State machine patterns and transitions
- Event-driven processing and triggers
- Parallel processing and synchronization

**4. Data Migration Patterns:**
- Import/export configurations and mappings
- Data transformation rules and cleansing
- Legacy system integration patterns
- Incremental data synchronization

**5. Advanced Business Logic:**
- Complex calculation engines
- Rule-based decision making
- Dynamic configuration management
- Multi-tenant data isolation

**6. Testing and Debugging:**
- Unit test patterns for business classes
- Mock data generation for testing
- Debug logging and tracing capabilities
- Performance monitoring and profiling

**IMPLEMENTATION PRIORITIES:**
1. Complete validation and constraint syntax patterns
2. Advanced field calculation and dependency management
3. Comprehensive error handling and recovery mechanisms
4. Performance optimization patterns and best practices
5. Integration patterns for external systems and APIs
6. Security and authorization framework enhancements

=== SANFORD PURCHASE ORDER RECEIPT INTERFACE ANALYSIS ===

**DOCUMENT OVERVIEW:**
- Document: INT_003 Purchase Order Receipt Inbound Interface
- Author: Cherry Estrada (Initial), Julianne Sitoy (Updates)
- Version: 1.1 (Last Updated: 8/4/2025)
- Purpose: Interface between FSM and third-party systems (Niko Health, Made4Net, SC Logic)

**BUSINESS REQUIREMENTS:**
- **Frequency:** Every 20 minutes, 24/7 continuous processing
- **Source Systems:** Niko Health, Made4Net, SC Logic
- **Target System:** Infor FSM (Finance and Supply Management)
- **File Format:** CSV pipe-delimited
- **Transport:** SFTP repository maintained by Sanford

**INTERFACE COMPONENTS:**
1. **Header File (PORI):** PurchaseOrderReceiptImport business class
2. **Line File (PORL):** PurchaseOrderReceiptLineImport business class
3. **Detail File (PORD):** POReceiptInventoryDetailImport business class (Optional)

**FILE NAMING CONVENTIONS:**
- **Header:** PORI_<3rd Party System>_xxx.csv
- **Line:** PORL_<3rd Party System>_xxx.csv
- **Detail:** PORD_<3rd Party System>_xxx.csv (Optional)
- **Third Party Codes:** M4NS (Made4Net Shipment), M4NR (Made4Net Receipt), SCLO (SC Logic), NIKO (Niko Health)

**SFTP DIRECTORY STRUCTURE:**
- **Input:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/
- **Archive:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/Archive
- **Error:** /Infor_FSM/SAN/PurchaseOrderReceiptImport/Error

**BUSINESS PROCESS FLOW:**
1. Third-party systems drop files to SFTP every 20 minutes
2. IPA processes files to update PO Lines (EXT29 reference)
3. IPA imports PO receipts into import business classes
4. IPA triggers interface action with criteria: RunGroup, Company
5. Records become available in Manage Purchase Order Receipts

**FIELD MAPPINGS IDENTIFIED:**

**PurchaseOrderReceiptImport Fields:**
- Company (Default mapping)
- PurchaseOrderReceiptImport (Interface identifier)
- RunGroup (File name reference)
- InterfacedPurchaseOrder (Same as PurchaseOrderReceiptImport)
- Reference Number, BillOfLanding, ReceiptComments

**PurchaseOrderReceiptLineImport Fields:**
- Company, PurchaseOrderReceiptImport, LineNumber, RunGroup
- SequenceNumber (FSM Item number)
- Location (FSM ItemLocation)
- EnteredReceivedQuantity, ReceivedUOM, OriginalUnitCost
- CancelBackorder, RecComments

**POReceiptInventoryDetailImport Fields (Optional):**
- Company, PurchaseOrderReceiptImport, LineNumber, SequenceNumber
- RunGroup, Serial, Lot, Quantity, LotExpirationDate

**ERROR HANDLING & NOTIFICATIONS:**
- Consolidated error reporting after processing
- Email notifications to TBD recipients
- Error file generation in designated SFTP error directory
- Multiple error scenarios covered (Import Failed, File Not Found, Async Trigger Failed)

**INTERFACE PARAMETERS:**
- Run Group: Purchase Order Receipt Import (File Name)
- Release Receipt: Default = No
- Release Option: Receive and Deliver
- Various configuration options for dropship, item matching, error handling

**KEY BUSINESS RULES:**
- Header and Line files can be processed independently
- Detail file is optional for serial/lot controlled items
- Existing PO detail records retained if no Detail file provided
- PO not updated if no existing details but Detail file provided
- Validation checks ensure data quality before FSM integration

**TECHNICAL SPECIFICATIONS:**
- Automated process flow for file consumption
- Background processing with error recovery
- Integration with existing FSM business classes
- Support for multi-entity processing (Company-based)

**INTEGRATION PATTERNS FOR LPL:**
This analysis provides insights for LPL business class design patterns:
- Import business class structures for external data integration
- File-based interface processing workflows
- Error handling and notification systems
- Multi-file processing with optional components
- SFTP-based data exchange patterns
- Automated scheduling and background processing
- Field mapping strategies for external system integration

**GENERATED BUSINESS CLASSES:**

**cfgPurchaseOrderReceiptImport (Header):**
- Company (Numeric 4) - Default company mapping
- PurchaseOrderReceiptImport (Alpha 15) - Interface identifier
- RunGroup (Alpha 20) - File name reference for processing
- PurchaseOrder (Alpha 15) - Purchase order reference
- BillOfLading (Alpha 20) - Bill of lading information
- ReceiptComments (Alpha 100) - Receipt comments
- ProcessReceipts Set Action for batch processing by RunGroup and Company

**cfgPurchaseOrderReceiptLineImport (Line):**
- Company (Numeric 4) - Default company mapping
- PurchaseOrderReceiptImport (Alpha 15) - Links to header record
- LineNumber (Numeric 3) - Line sequence number
- SequenceNumber (Numeric 3) - FSM item sequence number
- RunGroup (Alpha 20) - File name reference for processing
- Location (Alpha 10) - FSM item location
- EnteredReceivedQuantity (Numeric 12) - Received quantity
- ReceivedUOM (Alpha 5) - Unit of measure
- OriginalUnitCost (Numeric 12) - Unit cost
- CancelBackorder (Boolean) - Backorder cancellation flag
- RecComments (Alpha 100) - Receipt comments
- Relation to header business class for data integrity
- ProcessLineReceipts Set Action for batch processing

**CSV FIELD MAPPING ANALYSIS:**
Based on sample files PORI_M4NS_1234_20250814.csv and PORL_M4NS_1234_20250814.csv:
- Pipe-delimited format with header row
- Company values: 3020 (4-digit numeric)
- RunGroup values: SANR, SANU (4-character codes)
- Purchase order numbers: 30200000349, 30200000350 (11-digit format)
- Location codes: GS0071 (6-character alphanumeric)
- Quantities: 150, 30 (numeric values)
- UOM: BX (2-character unit codes)
- Unit costs: 32, 30 (numeric values)
- Boolean flags: 0 (false for CancelBackorder)

=== PURCHASE ORDER RECEIPT IMPORT BUSINESS CLASS PATTERNS ===

**IMPORT BUSINESS CLASS DESIGN:**
- Prefix naming convention: PORI (header), PORL (line)
- Company-based multi-entity support
- RunGroup field for batch processing identification
- Set Actions with parameter-driven filtering
- Symbolic key relations between header and line records

**FIELD SIZING ANALYSIS:**
- Company: Numeric 4 (supports 4-digit company codes)
- Identifiers: Alpha 15 (accommodates 11+ character PO numbers)
- RunGroup: Alpha 20 (supports various naming conventions)
- Location: Alpha 10 (handles 6+ character location codes)
- Quantities/Costs: Numeric 12 (supports large values with decimals)
- UOM: Alpha 5 (accommodates standard unit codes)
- Comments: Alpha 100 (sufficient for integration timestamps and messages)

**PROCESSING PATTERNS:**
- Set Actions for batch processing by RunGroup and Company criteria
- Primary sort by Company and identifier fields
- Secondary sort by RunGroup for processing efficiency
- One-to-one relation from line to header for data integrity

=== SET IS SYNTAX ANALYSIS ===

**'Set Is' SYNTAX PATTERN:**
The 'Set Is' syntax is used within Set Actions to define the data set that the action will operate on. It appears in the GLTransactionDetail.busclass file as a way to specify which records should be included in the set action processing.

**SYNTAX STRUCTURE:**
```lpl
ActionName is a Set Action
    Parameters
        // Parameter definitions
    Instance Selection
        where (conditions)
    Set Is
        ParameterName
    Sort Order
        // Sort fields
    Action Rules
        // Processing logic
```

**IDENTIFIED USAGE PATTERNS:**

1. **CreateDetailsForJournalTransaction Set Action:**
```lpl
CreateDetailsForJournalTransaction is a Set Action
    restricted
    Parameters
        PrmRelatedJournalTransaction is BusinessObjectReference
    Set Is
        PrmRelatedJournalTransaction
    Instance Selection
        where (RelatedJournalTransaction.BusinessClassName = PrmRelatedJournalTransaction.BusinessClassName
        and   RelatedJournalTransaction.BusinessObjectKey = PrmRelatedJournalTransaction.BusinessObjectKey)
```

2. **BuildProcurementExpenseRecords Set Action:**
```lpl
BuildProcurementExpenseRecords is a Set Action
    restricted
    Instance Selection
        where ((JournalizeGroup entered
        and    Status = Status.History
        and   !GLProcurementExpenseRel exists)
        and   (System = "AP"
        or     System = "IC"
        or     System = "RQ"
        or     System = "PO"))
    Set Is
        // Empty Set Is declaration
    Sort Order is ByJournalizeGroup
```

**KEY CHARACTERISTICS:**
- **Purpose**: Defines the parameter or field that determines the set grouping for the action
- **Position**: Appears after Parameters and Instance Selection, before Sort Order
- **Usage**: Can reference a parameter name or be left empty
- **Function**: Controls how records are grouped during set action processing

**FUNCTIONAL BEHAVIOR:**
- When 'Set Is' references a parameter, records are grouped by that parameter's value
- Empty 'Set Is' declarations indicate no specific grouping parameter
- Used in conjunction with Instance Selection to filter and group records
- Affects how Action Rules are applied to the selected record set

**BUSINESS LOGIC INTEGRATION:**
- Enables batch processing of related records
- Supports complex transaction processing workflows
- Facilitates data aggregation and summarization
- Allows for parameter-driven record grouping

**ADVANCED PATTERNS:**
- Can be combined with Accumulators for set-level calculations
- Works with Sort Order to control processing sequence
- Supports nested Set Rules for hierarchical processing
- Integrates with Instance Selection for complex filtering logic

**GLTRANSACTIONDETAIL KEY LEARNINGS:**
1. **Conditional Compilation:** Use #ifdef/#endif for module-specific functionality
2. **Complex Derived Fields:** Support multi-step conditional logic with business class name checking
3. **Advanced Relations:** Implement complex field mappings with instance selection filtering
4. **Currency Processing:** Handle multi-currency scenarios with automatic conversion
5. **Inter-Entity Processing:** Create balancing entries across multiple accounting entities
6. **Zone Balancing:** Implement advanced zone accounting for organizational structures
7. **Set Actions:** Use complex set actions for batch processing with parameter validation
8. **Rule Blocks:** Implement multi-step rule blocks for complex business logic
9. **Field Attributes:** Use specialized attributes for audit control and system integration
10. **Business Object References:** Implement typed references for cross-entity relationships

=== DETAIL SECTIONS SYNTAX ===

**OVERVIEW:**
Detail Sections is a List syntax construct that defines tabbed or sectioned views within a list interface, enabling organized display of related data, forms, and sub-lists with conditional visibility and advanced layout options.

**BASIC SYNTAX STRUCTURE:**
```lpl
ListName is a List
    title is "ListTitle"
    Display Fields
        // Field definitions
    Detail Sections
        SectionName
            title is "SectionTitle"
            visible when (condition)
            list is RelationName.ListName
        FormSection
            form is FormName
        MultiViewSection is a MultiListView
            Detail Sections
                // Nested sections
```

**DETAIL SECTIONS COMPONENTS:**

**1. BASIC SECTION TYPES:**
- **List Sections:** Display related records using relations
- **Form Sections:** Show detailed forms for current record
- **Multi-List Views:** Container for multiple related lists
- **Dashboard Views:** Grid-based layout with column spanning

**2. SECTION ATTRIBUTES:**
- **title:** Display label for the section tab
- **visible when:** Conditional visibility based on field values
- **list:** Reference to relation and specific list view
- **form:** Reference to form definition for display
- **span N columns:** Column width in dashboard views (1-12)

**3. ADVANCED LAYOUT OPTIONS:**
- **MultiListView:** Container for multiple related sections
- **DashBoardView:** Grid-based layout with column control
- **use 12 column grid:** Enable responsive grid layout
- **show single panel tab:** Display only one section at a time
- **allow nested detail sections:** Enable hierarchical section nesting

**SYNTAX PATTERNS:**

**1. SIMPLE LIST SECTION:**
```lpl
Detail Sections
    LogDataDetail
        title is "LogDetails"
        list is LogDataDetailRel.LogDataDetailList
```

**2. CONDITIONAL VISIBILITY:**
```lpl
Detail Sections
    YesNoDetails
        visible when (ResponseType.YesNo)
        list is QuestionAnswer set.QuestionYesNoAnswers
    ListDetails
        visible when (ResponseType.List)
        list is QuestionAnswer set.QuestionListAnswers
```

**3. FORM SECTIONS:**
```lpl
Detail Sections
    Details
        form is DetailsForm
    Summary
        form is Summary
```

**4. MULTI-LIST VIEW WITH NESTED SECTIONS:**
```lpl
Detail Sections
    Recommendations is a MultiListView
        visible when (IsPerpetualLocation)
        Detail Sections
            KPIList
                list is IIHItemLocation.KpiList
            Recommendation
                list is IIHItemLocation.ItemDetailRecommendationGridViewList
            DailyDataChart
                visible when (not FillGraphGaps)
                list is IIHDailyDataRel.DailyTransactionChartView
```

**5. DASHBOARD VIEW WITH COLUMN SPANNING:**
```lpl
Detail Sections
    Information is a DashBoardView
        use 12 column grid
        Detail Sections
            Specifications
                span 4 columns
                form is Specifications
            Reference
                span 4 columns
                form is Reference
            ItemInformation
                span 3 columns
                form is IIHItemLocation.GeneralStatistics
```

**6. HELPER LISTS WITH ACTIONS:**
```lpl
Detail Sections
    AssetAdjustment
        title is "Adjustments"
        visible when (ShowMassSelectionAdjustment)
        list is MassSelectionDetailsRel.MassAdjustmentSelections
            helper list is AssetsForAdjustmentRel.AssetsForSelectionHelper
                action is IncludeInMassSelection
```

**ADVANCED FEATURES:**

**1. NESTED DETAIL SECTIONS:**
- Support hierarchical organization of related data
- Enable complex multi-level navigation structures
- Allow conditional display at multiple levels

**2. RESPONSIVE GRID LAYOUT:**
- 12-column grid system for flexible layouts
- Column spanning for different section widths
- Responsive design adaptation

**3. CONDITIONAL VISIBILITY:**
- Field-based conditional display logic
- Complex boolean expressions for visibility
- Dynamic section showing/hiding based on data state

**4. HELPER LISTS:**
- Secondary lists for selection and action operations
- Integration with primary list data
- Action buttons for data manipulation

**5. SINGLE PANEL TABS:**
- Exclusive section display (only one visible at a time)
- Tab-based navigation between sections
- Optimized for focused data viewing

**BUSINESS USE CASES:**

**1. MASTER-DETAIL INTERFACES:**
- Header record with multiple detail sections
- Related transaction displays
- Document line item management

**2. DASHBOARD LAYOUTS:**
- KPI and metrics display
- Multi-section information panels
- Responsive business intelligence views

**3. WORKFLOW INTERFACES:**
- Step-based process navigation
- Conditional section availability
- Progress-driven section display

**4. ANALYSIS AND REPORTING:**
- Multi-dimensional data views
- Chart and graph integration
- Drill-down capability through sections

**IMPLEMENTATION BEST PRACTICES:**

**1. SECTION ORGANIZATION:**
- Group related functionality logically
- Use descriptive section titles
- Implement consistent visibility patterns

**2. PERFORMANCE OPTIMIZATION:**
- Use conditional visibility to reduce data loading
- Implement efficient relation queries
- Consider lazy loading for large datasets

**3. USER EXPERIENCE:**
- Provide clear navigation between sections
- Use appropriate layout types for content
- Implement responsive design principles

**4. DATA INTEGRITY:**
- Ensure proper relation definitions
- Validate conditional logic thoroughly
- Test section interactions comprehensively

**COMMON PATTERNS:**

**1. TRANSLATION LISTS:**
- Standard Detail Sections for multi-language support
- Form-based translation interfaces
- Language-specific section visibility

**2. IMPORT/EXPORT INTERFACES:**
- Detail sections for processing results
- Error and success message displays
- File processing status sections

**3. FINANCIAL TRANSACTION VIEWS:**
- Header-line-distribution hierarchies
- Multi-currency display sections
- Audit trail and history sections

**4. INVENTORY AND ASSET MANAGEMENT:**
- Location-based detail sections
- Serial/lot tracking displays
- Movement history and analytics

**INTEGRATION WITH OTHER LPL CONSTRUCTS:**
- **Relations:** Provide data sources for list sections
- **Forms:** Define section content and layout
- **Actions:** Enable section-specific operations
- **Conditions:** Control section visibility and behavior
- **Sets:** Organize and filter section data

=== INTERFACE BUSINESS CLASS BEST PRACTICES ===

**NAMING CONVENTIONS:**
- Use 'cfg' prefix for business classes as specified in rules
- Descriptive field names matching source system terminology
- Consistent naming between related business classes

**DATA INTEGRITY:**
- Relations between header and line records
- Symbolic key mapping for standard field connections
- Appropriate field sizing based on sample data analysis

**PROCESSING EFFICIENCY:**
- Set Actions with parameter filtering for batch operations
- Multiple sort orders for different processing scenarios
- RunGroup-based processing for file-specific operations

**FIELD TYPE SELECTION:**
- Numeric fields for company codes, quantities, and costs
- Alpha fields for identifiers, codes, and comments
- Boolean fields for flags and indicators
- Appropriate sizing based on actual data requirements

=== CREATE ACTION SYNTAX ===

**CREATE ACTION DEFINITION:**
- Syntax: "ActionName is a Create Action"
- Used to create new records in a business class
- Enables record creation functionality within LPL business classes
- Standard action type for data insertion operations

**BASIC CREATE ACTION PATTERN:**
```lpl
CreateActionName is a Create Action
    // Action logic and rules
```

=== UPDATE ACTION SYNTAX ===

**UPDATE ACTION DEFINITION:**
- Syntax: "ActionName is an Update Action"
- Used to update existing records in a business class
- Enables record modification functionality within LPL business classes
- Standard action type for data modification operations

**BASIC UPDATE ACTION PATTERN:**
```lpl
UpdateActionName is an Update Action
    // Action logic and rules
```

=== DELETE ACTION SYNTAX ===

**DELETE ACTION DEFINITION:**
- Syntax: "ActionName is a Delete Action"
- Used to logically delete records from a business class
- Enables record deletion functionality within LPL business classes
- Standard action type for data removal operations

**BASIC DELETE ACTION PATTERN:**
```lpl
DeleteActionName is a Delete Action
    // Action logic and rules
```

=== PURGE ACTION SYNTAX ===

**PURGE ACTION DEFINITION:**
- Syntax: "ActionName is a Purge Action"
- Used to permanently delete all traces of records from a business class
- Enables complete record removal functionality within LPL business classes
- Standard action type for permanent data removal operations
- Compared to Delete actions that maintain logical trails, Purge actions remove all traces

**BASIC PURGE ACTION PATTERN:**
```lpl
PurgeActionName is a Purge Action
    // Action logic and rules
```

=== USER INTERACTION PATTERNS ===

**GREETING RESPONSES:**
- Users may greet with informal terms like "Hayup" (Filipino greeting)
- Respond professionally while acknowledging the greeting
- Immediately offer LPL assistance and available services
- Maintain focus on LPL development tasks

=== SANFORD INTERFACE IMPLEMENTATION NOTES ===

**BUSINESS CLASS GENERATION COMPLETED:**
1. **cfgPurchaseOrderReceiptImport** - Header business class for PORI files
2. **cfgPurchaseOrderReceiptLineImport** - Line business class for PORL files

**KEY IMPLEMENTATION FEATURES:**
- Field mappings based on actual CSV sample data structure
- Appropriate data types and sizes for all fields
- Relations between header and line records for data integrity
- Set Actions for batch processing by RunGroup and Company
- Multiple sort orders for efficient data retrieval
- Standard CRUD actions for data management

**SAMPLE DATA ANALYSIS:**
- Company: 3020 (4-digit numeric format)
- Purchase Orders: 30200000349, 30200000350 (11-digit format)
- RunGroups: SANR, SANU (4-character processing codes)
- Locations: GS0071 (6-character location codes)
- Quantities: 150, 30 (whole numbers)
- UOM: BX (2-character unit codes)
- Unit Costs: 32, 30 (numeric values)
- Comments: Timestamped integration messages

**PROCESSING WORKFLOW SUPPORT:**
- RunGroup parameter for file-specific processing
- Company parameter for multi-entity operations
- Set Actions enable batch processing as required

=== COMPLEX BUSINESS CLASS PATTERNS ===

**ADVANCED BUSINESS CLASS FEATURES:**
Generated cfgAdvancedCustomerContract demonstrates comprehensive LPL patterns:

**1. MULTI-FIELD TYPE INTEGRATION:**
- Context Fields with conditional compilation (#ifdef MULTI_CURRENCY)
- Persistent Fields with comprehensive data types and attributes
- Transient Fields for temporary processing data
- Local Fields for internal calculations and references
- Derived Fields with complex conditional logic

**2. ENUMERATED STATES:**
- ContractStatus states (Draft, Active, Suspended, Expired, Terminated)
- BillingCycle states (Monthly, Quarterly, SemiAnnual, Annual)
- Numeric value assignments for state management

**3. ADVANCED DERIVED FIELDS:**
- Status display formatting with conditional logic
- Currency formatting with concatenation
- Boolean calculations for business rules (IsExpiringSoon)
- Complex string manipulation (CustomerDisplayName)
- Date arithmetic (ContractAge)
- Regular expression validation (ValidContractNumber)

**4. COMPREHENSIVE CONDITIONS:**
- Business logic conditions (IsActiveContract, RequiresApproval)
- Date range validation with complex expressions
- Restricted conditions for internal use

**5. MULTI-TYPE RELATIONS:**
- One-to-one relations with symbolic key mapping
- One-to-many relations with custom field mapping
- Instance Selection for filtered data retrieval
- Multiple relations to different business classes

**6. ADVANCED SETS:**
- Multiple sort orders for different use cases
- Instance Selection with complex filtering
- Performance-optimized sorting strategies

**7. COMPREHENSIVE FIELD RULES:**
- Required field validation with conditions
- Regular expression constraints
- Range validation for numeric fields
- Cross-field validation logic
- Conditional requirements based on other fields

**8. SOPHISTICATED ACTIONS:**
- Standard CRUD actions (Create, Update, Delete)
- Instance Actions with business logic
- Set Actions with parameters and filtering
- Accumulators for set-level calculations
- Complex action rules with conditional processing

**9. PATTERN IMPLEMENTATIONS:**
- StandardAuditTrail pattern for change tracking
- MultiCurrencySupport pattern for international operations

**BUSINESS LOGIC COMPLEXITY:**
- Contract lifecycle management
- Automatic renewal processing
- Expiration notification workflows
- Revenue calculation and reporting
- Multi-entity processing support
- Comprehensive validation and constraint enforcement

**FIELD ATTRIBUTE USAGE:**
- PII protection with "holds pii" attribute
- UI customization with "default label" attribute
- Access control with "restricted" attribute in Field Rules
- Data integrity with comprehensive constraint definitions

**PERFORMANCE CONSIDERATIONS:**
- Efficient set definitions for common queries
- Optimized relation mappings
- Strategic use of derived fields for display logic
- Appropriate field sizing for data storage efficiency

=== SET IS SYNTAX IN SET ACTIONS ===

**OVERVIEW:**
The 'Set Is' syntax within Set Actions defines the parameter or field that determines how records are grouped during set action processing. It controls which parameter drives the set grouping logic.

**SYNTAX STRUCTURE:**
```lpl
ActionName is a Set Action
    Parameters
        ParameterName is DataType
    Set Is
        ParameterName
    Instance Selection
        where (conditions)
    Sort Order
        // Sort fields
    Action Rules
        // Processing logic
```

**KEY CHARACTERISTICS:**
- **Purpose**: Defines the parameter or field that determines the set grouping for the action
- **Position**: Appears after Parameters and Instance Selection, before Sort Order
- **Usage**: Can reference a parameter name or be left empty
- **Function**: Controls how records are grouped during set action processing

**FUNCTIONAL BEHAVIOR:**
- When 'Set Is' references a parameter, records are grouped by that parameter's value
- Empty 'Set Is' declarations indicate no specific grouping parameter
- Used in conjunction with Instance Selection to filter and group records
- Affects how Action Rules are applied to the selected record set

**EXAMPLES FROM GLTRANSACTIONDETAIL:**

**1. Parameter-Based Grouping:**
```lpl
CreateDetailsForJournalTransaction is a Set Action
    restricted
    Parameters
        PrmRelatedJournalTransaction is BusinessObjectReference
    Set Is
        PrmRelatedJournalTransaction
    Instance Selection
        where (RelatedJournalTransaction.BusinessClassName = PrmRelatedJournalTransaction.BusinessClassName
        and   RelatedJournalTransaction.BusinessObjectKey = PrmRelatedJournalTransaction.BusinessObjectKey)
```

**2. Empty Set Is Declaration:**
```lpl
BuildProcurementExpenseRecords is a Set Action
    restricted
    Instance Selection
        where ((JournalizeGroup entered
        and    Status = Status.History
        and   !GLProcurementExpenseRel exists)
        and   (System = "AP"
        or     System = "IC"
        or     System = "RQ"
        or     System = "PO"))
    Set Is
        // Empty Set Is declaration
    Sort Order is ByJournalizeGroup
```

**BUSINESS LOGIC INTEGRATION:**
- Enables batch processing of related records
- Supports complex transaction processing workflows
- Facilitates data aggregation and summarization
- Allows for parameter-driven record grouping

**ADVANCED PATTERNS:**
- Can be combined with Accumulators for set-level calculations
- Works with Sort Order to control processing sequence
- Supports nested Set Rules for hierarchical processing
- Integrates with Instance Selection for complex filtering logic

**USE CASES:**
- Transaction processing by journal reference
- Batch operations on related business objects
- Parameter-driven data aggregation
- Complex multi-step business rule processing
- Cross-entity relationship processing

**PROCESSING WORKFLOW:**
1. Parameters define the grouping criteria
2. Set Is specifies which parameter controls grouping
3. Instance Selection filters records for processing
4. Records are grouped by the Set Is parameter value
5. Action Rules execute on each group separately
6. Sort Order determines processing sequence within groups

=== SECURITY CLASS ANALYSIS: DataMenuAccess_ST ===

**SECURITY CLASS STRUCTURE:**
- SecurityClass is a core LPL construct for defining access control and permissions
- Syntax: "ClassName is a SecurityClass"
- Contains Access Rights section defining permission rules

**DataMenuAccess_ST ANALYSIS:**
```lpl
DataMenuAccess_ST is a SecurityClass
    Access Rights
        @this DataArea
            is accessible
                for data menu
                unconditionally
```

**KEY COMPONENTS:**

**1. ACCESS RIGHTS SECTION:**
- Defines permission rules and access control logic
- Specifies what resources can be accessed and under what conditions
- Uses declarative syntax for permission definitions

**2. RESOURCE REFERENCE (@this DataArea):**
- @this keyword refers to the current context/instance
- DataArea represents the data scope or organizational unit
- Establishes the target resource for access control

**3. ACCESSIBILITY DECLARATION:**
- "is accessible" grants permission to the specified resource
- Defines the type of access being granted
- Can include conditional logic for complex permission rules

**4. ACCESS TYPE SPECIFICATION:**
- "for data menu" specifies the type of access being granted
- Indicates this security class controls data menu visibility/access
- Restricts permissions to specific functional areas

**5. CONDITION MODIFIER:**
- "unconditionally" means no additional restrictions apply
- Access is granted without further validation or constraints
- Alternative: conditional access with specific criteria

**SECURITY CLASS PATTERNS:**

**1. UNCONDITIONAL ACCESS:**
```lpl
SecurityClassName is a SecurityClass
    Access Rights
        @this ResourceType
            is accessible
                for specific_function
                unconditionally
```

**2. CONDITIONAL ACCESS:**
```lpl
SecurityClassName is a SecurityClass
    Access Rights
        @this ResourceType
            is accessible
                for specific_function
                when (condition)
```

**BUSINESS PURPOSE:**
- Controls data menu access within the application
- Ensures users can view/access data menus based on security assignments
- Part of role-based access control (RBAC) system
- Enables organizational data segregation and security

**IMPLEMENTATION CONTEXT:**
- Security classes are assigned to user roles or profiles
- Multiple security classes can be combined for comprehensive access control
- DataMenuAccess_ST specifically handles data menu navigation permissions
- Works in conjunction with other security classes for complete access management

**SECURITY FRAMEWORK INTEGRATION:**
- Part of LPL's comprehensive security and authorization system
- Integrates with user authentication and role management
- Supports fine-grained access control at functional level
- Enables audit trail and compliance tracking for access permissions

=== ACTION SECURITY ATTRIBUTES ===

**RESTRICTED ACTIONS:**
- Use "restricted" attribute to prevent action accessibility through security classes
- Syntax: "ActionName is an ActionType restricted"
- Applies to all action types: Instance, Create, Update, Delete, Set, Purge actions
- Restricted actions are only accessible programmatically through LPL code
- Prevents user interface exposure while maintaining system functionality
- Enables internal system operations with controlled access

**RESTRICTED ACTION EXAMPLES:**
```lpl
SystemAction is an Instance Action
    restricted
    // Internal system processing only

InternalCreate is a Create Action
    restricted
    // Programmatic record creation only

BackgroundProcess is a Set Action
    restricted
    // Batch processing without user access
```

**SECURITY CLASS INTERACTION:**
- Restricted actions do not appear in security class configurations
- Cannot be assigned permissions through Access Rights sections
- Provide system-level functionality without user interface exposure
- Enable secure internal operations and automated processes

**SECURITY CLASS ACTION RESTRICTIONS:**
- Security classes can restrict access to NON-RESTRICTED actions only
- Actions marked "restricted" are invisible to security classes
- Use "is not accessible" to deny action access
- Use "is accessible when (condition)" for conditional access

**SECURITY CLASS ACTION CONTROL EXAMPLES:**
```lpl
RestrictedOperations is a SecurityClass
    Access Rights
        @this BusinessClassName
            ActionName is not accessible
            ConditionalAction is accessible
                when (actor.Department = "Sales")
            UnconditionalDenial is not accessible
                unconditionally
```

**ACTION ACCESS PATTERNS:**
- "ActionName is not accessible" - denies action access
- "ActionName is accessible when (condition)" - conditional access
- "ActionName is not accessible unconditionally" - explicit denial
- Security classes only control user-facing (non-restricted) actions


=== COMPLEX BUSINESS CLASS EXAMPLE ===

**CUSTOMER ORDER BUSINESS CLASS PATTERN:**
Generated cfgCustomerOrder and cfgCustomerOrderLine as comprehensive examples demonstrating:

**HEADER-LINE RELATIONSHIP:**
- cfgCustomerOrder (header) with order-level information
- cfgCustomerOrderLine (line) with item-level details
- One-to-many relation from header to lines
- One-to-one relation from line back to header

**FIELD VARIETY:**
- Persistent Fields: Company, identifiers, dates, amounts, status codes
- Derived Fields: Calculated amounts (NetAmount), status displays (OrderStatus), validations (IsOverdue)
- Substring extraction in derived fields (ItemCode extracts first 6 characters)
- Boolean derived fields for business logic (IsValidItem, IsOverdue)

**BUSINESS LOGIC:**
- Conditions for status checking (IsOpen, IsShipped)
- Field Rules with regex validation and constraint checking
- Cross-field validation (RequiredDate >= OrderDate)
- Range constraints (DiscountPercent between 0 and 100)

**ACTIONS:**
- Standard CRUD actions (Create, Update, Delete)
- Set Action with parameters for batch processing (ProcessOrders)
- Instance Action for business operations (ShipOrder)

**DATA ORGANIZATION:**
- Multiple sort orders (ByOrderDate, ByCustomer, ByLineNumber)
- Symbolic key relations for data integrity
- Representative text for display purposes

**DERIVED FIELD CALCULATIONS:**
- NetAmount: TotalAmount - (TotalAmount * DiscountPercent / 100)
- LineTotal: OrderedQuantity * UnitPrice
- Substring extraction: Item[1:6] for ItemCode
- Pattern matching: Item[1:1] matches "^[A-Z]$" for validation


=== HL7 ITEM MASTER INTERFACE ANALYSIS ===

**BUSINESS TASK STRUCTURE:**
HL7ItemMasterInterface is a BusinessTask (not a BusinessClass) for HL7 interface processing.

**OWNERSHIP:**
- Owned by ic (Inventory Control module)

**PATTERNS IMPLEMENTED:**
1. **ManualTransaction** - Enables manual execution/triggering
2. **StaticJava** - Uses Java implementation with report generation
   - Report: HL7ItemMasterInterfaceReport

**PARAMETERS:**
- Company (InventoryCompany) - Required
- RevCenter (AlphaUpper size 5) - Required, Revenue Center code
- ReportGrp (InventoryReportGroup) - Optional, Report grouping
- Location (InventoryLocation) - Optional, Inventory location filter
- FileName (AlphaUpper size 30) - Optional, Output file name

**PARAMETER RULES:**
- Company is required (mandatory for execution)
- RevCenter is required (mandatory revenue center)

**ACTIONS:**
- HL7ItemMasterInterface is a Set Action
  - allow unlimited concurrency (supports parallel execution)

**KEY LEARNINGS:**

**1. BUSINESSTASK vs BUSINESSCLASS:**
- BusinessTask is used for processing/interface tasks
- BusinessClass is used for data entities
- BusinessTask syntax: "TaskName is a BusinessTask"

**2. PATTERN IMPLEMENTATIONS:**
- ManualTransaction: Enables user-triggered execution
- StaticJava: Integrates with Java code and report generation
- Reports section defines output reports

**3. PARAMETER TYPES:**
- Reference types: "is an InventoryCompany" (business class reference)
- AlphaUpper: Uppercase alpha field type
- Size specifications for parameter constraints

**4. CONCURRENCY CONTROL:**
- "allow unlimited concurrency" enables parallel processing
- Used in Set Actions for performance optimization

**5. INTERFACE TASK PATTERN:**
- Parameters define execution criteria
- Parameter Rules enforce required inputs
- Set Action processes records based on parameters
- Report generation for output/logging


=== COMPLEX BUSINESS CLASS PATTERNS ===

**COMPREHENSIVE BUSINESS CLASS STRUCTURE:**
A complex business class demonstrates multiple advanced LPL features:
- Multiple field states with enumerated values
- Complex conditions for business logic evaluation
- Derived fields with multi-step conditional calculations
- Multiple relations with instance selection filtering
- Comprehensive field rules with validation constraints
- Multiple action types (Create, Update, Delete, Instance, Set)
- Audit trail fields (CreatedBy, CreatedDate, ModifiedBy, ModifiedDate)

**PROCUREMENT CONTRACT EXAMPLE:**
Generated cfgProcurementContract demonstrates:
- Status management with 7 states (Draft, PendingApproval, Approved, Active, Expired, Terminated, Renewed)
- Approval workflow with 4 approval states
- Complex conditions (IsActive, IsExpiringSoon, RequiresApproval, CanRenew)
- Derived fields for status display, percentage calculations, date calculations
- Multiple relations (vendor, contract lines, history, filtered active lines)
- Field validation with regex patterns and business rules
- Workflow actions (SubmitForApproval, ApproveContract, ActivateContract, RenewContract, TerminateContract)
- Set action for batch processing expiring contracts
- Automated notification and logging capabilities

**COMPLEX ACTION PATTERNS:**
- Instance Actions with constraint validation before execution
- Field updates with actor context (actor.name)
- Date-based calculations (current date)
- Relation existence checks in constraints
- Invoke actions for creating related records
- Set Actions with parameters for batch operations

**ADVANCED DERIVED FIELD CALCULATIONS:**
- Percentage calculations: ((TotalContractAmount - RemainingAmount) / TotalContractAmount) * 100
- Date arithmetic: EndDate - current date for days remaining
- String concatenation with currency symbols and formatting
- Boolean logic for budget overrun detection
- Multi-condition status determination with priority logic


=== STATES SYNTAX CORRECTION ===

**INCORRECT STATES SYNTAX:**
The States block with nested field states is NOT valid LPL syntax:
```lpl
// WRONG - Do not use this pattern
States
	Status
		Draft			value is 1
		PendingApproval		value is 2
	ApprovalStatus
		NotSubmitted		value is 1
		Pending			value is 2
```

**CORRECT APPROACH:**
Use string literals directly in conditions, derived fields, and actions:
- Conditions: when (Status = "Active")
- Derived Fields: if (Status = "Draft")
- Actions: update Status = "PendingApproval"
- Field Rules: default is "Active"

**STATES USAGE:**
States are defined at the field level, not in a separate States section. Use string values for field comparisons and assignments throughout the business class.
